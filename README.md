В репозитории находится несколько проектов.  

Logger: небольшая обертка над log4cplus для удобного логирования

Proto: простой протокол сообщений. Каждое сообщение состоит из заранее известного префикса msg# (4 байта), затем идет тип сообщения (4 байта), затем либо ID клиента (4 байта), либо payload (4 байта). Т.е. любое сообщение в текущей реализации занимает 12 байт.

Common: проект с общими для сервера и клиента функциями, типами и классами.

Client: небольшой клиент для отправки сообщений на балансировщик с учетом протокола сообщений Proto. Сперва отправляется инициализационное сообщение с ID клиента, затем регулярные сообщения со случайными числами. После записи последнего значения клиент проверяет, что все данные отправлены и закрывает соединение.  
У клиента есть параметры запуска для более удобной конфигурации: client, host, port и max_messages. Вес имеют адекватные дефолтные значения, обязательным является только client, который задает ID клиента.

Balancer: простой tcp-сервер, запускается строго на порту 8888. Т.к. сервер однопоточный можно не защищать блокировкой операции, связанные со списком tcp-сессий.  
Вся основная логика находится в классе tcp-сессии: на старте сессии пытаемся прочитать инициализационное сообщение, после всех проверок получаем адрес сервера, куда необходимо перенаправлять сообщения, затем отправляем туда данные. Для удобства отладки на стороне балансировщика происходит разбор сообщения с выводом в лог ID подключившегося клиента и данных, которые он отправляет, но на сервер отправляются сырые данные, как пришли с клиента (с префиксом и т.д.).  
На старте балансировщик пытается прочитать карту маршрутизации (считаем, что файл валидный, никакие проверки при чтении не делаем), для указания пути до карты есть ключ запуска route_map с дефолтным значением ./route-map.txt. Сам файл присутствует в каталоге проекта в папке src. 


Что можно сделать/улучшить:  

Proto: в первую очередь можно расширить возможные типы данных для отправки, сейчас можно отправлять только  uint32. Например, для строк можно хранить в первых 4 байтах длину, а затем сами данные, для остальных типов по аналогии. Главное загружать данные из потока в порядке, обратном сохранению. Из-за этого возникнет некоторая сложность на стороне получения, т.к. заранее длина сообщения будет неизвестна, и его придется подгружать частями. В рамках работы над заданием не хотелось усложнять, поэтому мы заранее знаем длину каждого типа сообщения и можем на принимающей стороне сперва дождаться поступления всех данных, а потом их распарсить.

Client: можно добавить работу с таймерами подключения к серверу и записи данных. Так же можно ограничивать поток записываемых данных, если сервер не успевает их прочитать. Сейчас все сыпется на сервер без ограничений. Написать тесты, но нужно будет хорошо подумать над инкапсуляцией io-части.

Balancer: предложения аналогичны предложениям для клиента. На текущий момент я бы назвал это не балансировщиком, а односторонним прокси, т.к. нет никаких данных о количестве поступающих сообщений на тот или иной сервер, времени их обработки, загруженности и т.д. Так же можно было бы реализовать возможность указать для клиента несколько серверов, выбор одного из них был бы основан на вышеуказанных статистиках. Все это можно было бы реализвать в будущем.


Тестирование:  
В разных окнах терминала/машинах запускаем:
1. ./Balancer
2. socat - TCP-LISTEN:7777,fork
3. socat - TCP-LISTEN:9999,fork
4. ./Client --client 1
5. ./Client --client 2
6. ./Client --client 3
